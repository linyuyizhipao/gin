#基于gin开启go自定义web基础组件构建篇

main.go中
* 1.配置初始化。2.日志初始化。3。models初始化。4.redis拓展再度封装并初始化，5.路由初始化。
* 其实任何后期app中需要用到的服务，如果第三方包封装得不够简洁，我们便可在extend中做一层再度封装，那么业务逻辑中便可精简着使用
* 业务自身支撑的拓展包则在extend同级别目录建立

# 竞拍系统

灵感来自于小伙伴商品竞拍项目。场景：后台将商品编辑进入竞拍集合中（当然编辑的时候会附加该商品竞拍开始时间，竞拍时间等等竞拍必要的条件），
用户端看到的是一个竞拍列表的页面，页面里面展示所有将要进行竞拍的商品列表，当一个商品到达了竞拍时间后，竞拍的灰化按钮就会被激活，所有用户
便可以通过点击该按钮进行往上竞价，该商品的最新价格以及每次参与人（简陋信息）也会实时展示给所有用户查看，从而用户可以决定自己继续竞拍与否。

后台技术需要给与如下保障：假设每个竞拍商品竞拍时间为10秒钟，每个商品有个最低允许被竞拍出去的价格为:M  ，那么当商品当前价格比M低的时候，就会出现
机器人模仿用户抬价，只有当价格大于M时机器人便不再参与抬价。


A.抬价服务：负责将用户当前对某一个商品抬价的金额传送到服务器，进入redis队列，便立即返回给客户端，客户端显示成功抬价，该用户的一次完整抬价流程便算走完 （后期多节点）

B.显示商品新产生的抬价记录的api：提供商品新产生的抬价记录的api（准备用redis的订阅发布）（后期多节点）

C.处理抬价消息的代码块：所有的消息为了保证快速入队，采用了根据商品id为规律的多队列，但不管多少个队列，最终是需要一处理这些消息的代码块，它必须快速稳定易多节点（后期多节点）

D.显示商品最终敲定人的api：一个商品可能被n个人同时竞拍，需要后台有个进程异步去检查当前所有商品最终的所有人是谁，并把商品锁定给他，
                      并推送给所有竞拍该商品的客户端，当然锁定前会检查该商品是否满足锁定条件，若不满足则调机器人服务去抬它的价格。（后期多节点）

E.机器人服务：机器人则也是服务器的另外一个协程处理器，它专门负责给商品偷偷抬价的


技术方案保证：
1.抬价api会把商品的抬价行为信息根据商品id数字组成部分（商品id的数字组成部分必须跟商品将要进入的抬价队列成映射关系，从而保证商品均匀入队，并且一个商品只会入一个队列）

2. C服务专门异步协程处理队列的，它会尽可能的一次从队列里面多取消息处理（但也不敢保证一次），从而更有力的去避免本在10秒内的竞拍由于系统10秒内没来及去处理，导致该商品被系统另外一专门负责锁定商品与用户关系的协程给处理了，导致用户竞拍由于硬件极限与商品错失，
所以这里得建立一个补偿机制，当队列最终（10秒过后）处理时发现后面这个用户竞拍的消息才是真正该锁定商品的（由于服务器性能造成的不可避免的错误锁定），进行日志记录，后面人工介入或者其他等等等方式

3.D,E服务所面对的数据单位为商品个数，也就是10000个商品也就只有10000条待处理的数据，所以相对数据量不是很大，可以组合运行，当D发现当前商品时间上满足了但是最低价格还不满足，则调用E服务区抬价
